# 配置生成与查看 Linux 的 `core dump` 文件

1. 由于 Ubuntu 自带的错误处理会捕获程序的错误，导致无法生成 core dump 文件，所以我们需要先修改配置文件， **持久地禁用 Apport 自动错误报告** 。

   ```shell
   sudo nano /etc/default/apport
   ```

   将 `enabled=1` 改为 `enabled=0`，然后保存并退出。

2. **设置 core dump 文件大小无限，确保其能生成** 

    ```shell
    ulimit -c unlimited
    ```

    此命令只在当前终端有用，查看是否设置成功可以使用：

    ```shell
    ulimit -c
    ```

    如果要想持久化可以使用命令：

    ```shell
    echo "ulimit -c unlimited" >> ~/.bashrc
    source ~/.bashrc
    ```

    将命令添加到文件中，每次终端启动自动执行。

3. **设置 core dump 文件生成位置为当前目录** 

    ```shell
    echo "core.%e.%p.%t" | sudo tee /proc/sys/kernel/core_pattern
    ```

    我们需要进行持久化，打开文件

    ```shell
    sudo nano /etc/sysctl.conf
    ```

    在末尾添加行：

    ```shell
    kernel.core_pattern = core.%e.%p.%t
    ```

    验证是否生效：

    ```shell
    cat /proc/sys/kernel/core_pattern
    ```

    正常应当输出 `core.%e.%p.%t`。

## 编写脚本

为了避免重复做这件事情，我们可以编写一个 `setup_core_dump.sh` 脚本：

```bash
#!/bin/bash

echo "=== 配置 Linux core dump 生成环境 ==="

# 1. 禁用 Apport 自动错误报告
echo "禁用 Apport 自动错误报告..."
sudo sed -i 's/enabled=1/enabled=0/' /etc/default/apport

# 2. 设置 core dump 文件大小无限
echo "设置 core dump 文件大小为 unlimited..."
echo "ulimit -c unlimited" >> ~/.bashrc
source ~/.bashrc

# 3. 设置 core dump 文件生成位置为当前目录
echo "设置 core dump 文件生成格式为 core.%e.%p.%t..."
echo "core.%e.%p.%t" | sudo tee /proc/sys/kernel/core_pattern > /dev/null
sudo bash -c 'echo "kernel.core_pattern = core.%e.%p.%t" >> /etc/sysctl.conf'
sudo sysctl -p

# 验证是否生效
echo "验证 core dump 文件生成格式..."
current_pattern=$(cat /proc/sys/kernel/core_pattern)

# 使用 if 判断验证设置是否成功
if [ "$current_pattern" == "core.%e.%p.%t" ]; then
    echo "core dump 文件生成格式设置成功: $current_pattern"
else
    echo "core dump 文件生成格式设置失败, 当前格式: $current_pattern"
fi

echo "=== 配置完成 ==="
```

```shell
chmod setup_core_dump.sh 777
./setup_core_dump.sh
```

## 编译代码测试

```cpp
#include <iostream>

void causeCrash() {
    int* ptr = nullptr; // 空指针
    std::cout << *ptr << std::endl; // 尝试解引用空指针，导致崩溃
}

int main() {
    std::cout << "Program is running." << std::endl;
    causeCrash(); // 调用会导致崩溃的函数
}
```

```shell
g++ test.cpp -g -O2 -o test
./test
```

 **`-g`**  选项是为了生成可调试信息，非常重要。

执行之后通常应该报错：

```shell
Program is running.
段错误 (核心已转储)
```

> 关键在于需要出现“ **核心已转储**”。

当前目录就会自动生成一个 `core.test.` 的 core dump 文件。

我们可以使用 gdb 进行调试：

```shell
gdb ./test core.test.20659
```

是先传可执行文件，再传 core dump 文件。然后就会告诉我们程序崩溃在哪一行了。

```cpp
root@gao-virtual-machine:/opt# gdb ./test core.test.20659 
GNU gdb (Ubuntu 12.1-0ubuntu1~22.04.2) 12.1
Copyright (C) 2022 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./test...
[New LWP 20659]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/x86_64-linux-gnu/libthread_db.so.1".
Core was generated by `./test'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  causeCrash () at test.cpp:5
5	    std::cout << *ptr << std::endl; // 尝试解引用空指针，导致--Type <RET>--Type <RET> for more, q to quit, c to continue without paging--
```

看倒数第二行，它告诉了我们崩溃在第二行，我们也可以使用 `list` 命令查看当前行附近的代码，以及使用 `bt` 命令查看调用栈，如：

```shell
(gdb) list
1	#include <iostream>
2	
3	void causeCrash() {
4	    int* ptr = nullptr; // 空指针
5	    std::cout << *ptr << std::endl; // 尝试解引用空指针，导致崩溃
6	}
7	
8	int main() {
9	    std::cout << "Program is running." << std::endl;
10	    causeCrash(); // 调用会导致崩溃的函数
(gdb) bt
#0  causeCrash () at test.cpp:5
#1  0x0000569084a17178 in main () at test.cpp:10
```

- list 命令显示了 test.cpp 的代码，特别是崩溃发生的函数 causeCrash()。

- bt（backtrace）命令显示了调用栈：
    **`#0` 表示崩溃发生在 causeCrash() 函数的第 5 行。** 
    **`#1` 表示 causeCrash() 是由 main() 函数调用的，第 10 行调用了 causeCrash()。** 

## 查看发布版本的 Qt 程序生成的 core dump 文件

需要注意我们需要在程序中 qmake 添加：

```shell
CONFIG(release, debug|release) {
    # Release 模式添加优化选项与调试符号
    QMAKE_CXXFLAGS += -O2 -g
}
```

主要是需要 `-g` 选项让程序生成调试符号。

在使用 CMake 的项目中，需要在 CMake 配置文件中添加以下内容：

```cmake
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2 -g")
```

这样可以确保在 Release 模式下也生成调试符号，以便在程序崩溃时生成 core dump 文件并进行调试。

另外值得一提的是使用  **linuxdeployqt 打包的可执行文件无法直接使用 gdb** ，我们只能使用 release 版本的普通可执行文件，加上 core dump 文件，才能使用 gdb 查看。

 **也可以使用 QtCreator 之类的 IDE 载入** ，非常方便。
